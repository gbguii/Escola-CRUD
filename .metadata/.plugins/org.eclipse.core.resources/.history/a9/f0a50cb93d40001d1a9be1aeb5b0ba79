package Implementation;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import Connection.CreateConnection;
import Exception.ShoolException;
import obj.StudentObj;

public class StudentImpl {
	
	
	/**
	 * Cria um novo usuário na base de dados.
	 * @param student objeto de usuário para ser criado.
	 * @throws SQLException em caso de erro.
	 */
	public void create(StudentObj student) throws SQLException {
		// Valida os campos
		this.validate(student);
		// Cria string para conter query de criação.
		StringBuilder sb = new StringBuilder();
		// Adiciona o query.
		sb.append("INSERT INTO students(student_first_name, student_last_name, student_dt_begin, student_dt_update, student_dt_end) VALUES(?,?,?,?,?)");
		// Cria um coneção com o banco.
		Connection connection = CreateConnection.getConection();
		try {
			// Recupera a hora atual.
			Calendar c = Calendar.getInstance();
			// Inicializa a preparação de execução.
			PreparedStatement stmt = connection.prepareStatement(sb.toString());
			// Define o primeiro pâmetro com primeiro nome.
			stmt.setString(1, student.getFirstName());
			// Define o segundo pâmetro com sobrenome.
			stmt.setString(2, student.getLastName());
			// Define o terceiro pâmetro com a data de inicio do registro.
			stmt.setDate(3, new Date(c.getTimeInMillis()));
			// Define o quarto pâmetro com a data de atualização do registro.
			stmt.setDate(4, new Date(c.getTimeInMillis()));
			// Define o ano de fim do registro.
			c.set(2200, 0, 0);
			// Define o quinto pâmetro com a data de fim do registro.
			stmt.setDate(5, new Date(c.getTimeInMillis()));
			// Executa a query.
			stmt.execute();
			// em caso de erro.
		} catch (SQLException e) {
			// lança a exceção.
			e.printStackTrace();
		}finally {
			// fecha a conexão com o banco.
			connection.close();
		}
	}
	
	public void update(StudentObj student) {
		this.validate(student);
	}
	
	public void delet(StudentObj student) {
		
	}
	
	/**
	 * Retorna a lista de estudantes cadastrado.
	 * @return a lista de estudantes cadastrado.
	 * @throws SQLException em caso de erro.
	 */
	public List<StudentObj> getStudentList() throws SQLException{
		// Inicializa a lista de retorno.
		List<StudentObj> studentList = new ArrayList<>();
		// Cria a conexão com o banco.
		Connection connection = CreateConnection.getConection();
		// Cria string para query.
		StringBuilder sb = new StringBuilder();
		sb.append("SELECT * FROM shool.students s ");
		sb.append("WHERE s.student_dt_end > current_timestamp");
		try {
			PreparedStatement stmt = connection.prepareStatement(sb.toString());
			ResultSet result = stmt.executeQuery();
			this.mappingObjectToList(result, studentList);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}finally {
			connection.close();
		}
		return studentList;
	}
	
	/**
	 * Retorna um estudante cadastrado pelo id informado.
	 * @param id identificador do estudante.
	 * @return um estudante cadastrado pelo id informado.
	 * @throws SQLException em caso de erro.
	 */
	public StudentObj getStudentById(Long id) throws SQLException {
		// Inicializa o objeto de retorno.
		StudentObj student = new StudentObj();
		// Cria a conexão com o banco de dados.
		Connection connection = CreateConnection.getConection();
		// String para query de consulta.
		StringBuilder sb = new StringBuilder();
		// Seleciona a tabela de consulta.
		sb.append("SELECT * FROM shool.students s ");
		// Filtra pelo id.
		sb.append("WHERE s.student_id = ? ");
		// Filtra por registro válidos.
		sb.append("AND s.student_dt_end > current_timestamp");
		try {
			// Prepara a consulta.
			PreparedStatement stmt = connection.prepareStatement(sb.toString());
			// Define o parâmetro do id.
			stmt.setLong(1, id);
			// Executa a query.
			ResultSet result = stmt.executeQuery();
			// Mapeia a consulta para o objeto de estudante.
			student = mappingObject(result);
			// em caso de erro ao executar a query.
		}catch (SQLException e) {
			// Lança execeção.
			e.printStackTrace();
		}finally {
			// Fecha a conexão com o banco de dados.
			connection.close();
		}
		// Retorna o estudante.
		return student;
	}
	
	/**
	 * Retorna um objeto de estudante.
	 * @param result resultado da consulta.
	 * @return um objeto de estudante.
	 * @throws SQLException em caso de erro.
	 */
	private StudentObj mappingObject(ResultSet result) throws SQLException {
		// Cria lista para receber o objeto de usuário.
		List<StudentObj> students = new ArrayList<>();
		// mapeia e popula a lista do tipo objeto de estudante.
		this.mappingObjectToList(result, students);
		// Retorna o primeiro objeto da lista.
		return students.get(0);
	}
	
	/**
	 * Mapeia e popula a lista de objeto de estudante.
	 * @param result resultado da consulta.
	 * @param studentList lista para ser populada.
	 * @throws SQLException em caso de erro.
	 */
	private void mappingObjectToList(ResultSet result, List<StudentObj> studentList) throws SQLException {
		if(result != null) {
			while(result.next()) {
				StudentObj student = new StudentObj();
				// Mapeia para o objeto o id do estudante.
				student.setId(result.getLong("student_id"));
				// Mapeia para o objeto o primeiro nome do estudante.
				student.setFirstName(result.getString("student_first_name"));
				// Mapeia para o objeto o sobrenome do estudante.
				student.setLastName(result.getString("student_last_name"));
				// Mapeia para o objeto a data de início do registro do estudante.
				student.setDtBegin(result.getDate("student_dt_begin"));
				// Mapeia para o objeto a data de atualização do registro do estudante.
				student.setDtUpdate(result.getDate("student_dt_update"));
				// Mapeia para o objeto a data de fim do registro do estudante.
				student.setDtEnd(result.getDate("student_dt_end"));
				studentList.add(student);
			}
		}
	}
	
	private void validate(StudentObj studant) {
		if(studant.getFirstName() == null || studant.getFirstName().isEmpty()) {
			throw new ShoolException("O primeiro nome está vazio");
		}
		if(studant.getLastName() == null || studant.getLastName().isEmpty()) {
			throw new ShoolException("O último nome está vazio");
		}
	}
}
